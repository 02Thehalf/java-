# 稀疏数组

## 1.介绍

![image-20220104151908635](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220104151908635.png)

第一行表示有几行几列几个不同值。

下面每一行记录非零值所在的行

6×7数组变为9×3数组

**案例：五子棋**

## 2.应用思路分析

![image-20220104154856417](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220104154856417.png)

### a.二维数组转稀疏数组思路

1.遍历原始的二维数组，得到有效数据的个数sum

2.根据sum就可以创建稀疏数组sparseArr $int[sum+1][3]$

3.将二维数组的有效数据存入到稀疏数组

### b.稀疏数组转原始的二维数组

1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的$chessArr2=int[11][11]$

2.再读取稀疏数组后几行的数据，并赋给原始的二维数组即可。



# 队列

## 1.介绍

1. 队列是一个有序列表，可以用**数组**或是**链表**来实现。
2. 遵循**先入先出**的原则。即：先存入队列的数据，要先取出。后存入的要后取出
3. 示意图：(使用数组模拟队列示意图)

![image-20220116121316376](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220116121316376.png)

## 2.数组模拟队列

​	当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：**思路分析** 

1)将尾指针往后移：rear+1 , 当front == rear 【空】

2)若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear所指的数组元素中，否则无法存入数据。 rear == maxSize - 1[队列满]

![image-20220116121428294](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220116121428294.png)

**数组只能用一次不能复用。**



## 3.数组模拟环形队列

![image-20220116202233561](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220116202233561.png)

![image-20220116202300129](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220116202300129.png)

![image-20220116202314932](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220116202314932.png)

![image-20220116202340121](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220116202340121.png)

![image-20220116202359424](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220116202359424.png)

![image-20220116202420690](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220116202420690.png)



### 思路

1. front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 `arr[front]` 就是队列的第一个元素 front 的初始值 = 0
2.  rear 变量的含义做一个调整：rear 指向队列的最后一个元素的下一个位置. 因为希望空出一个空间做为约定.rear 的初始值 = 0
3.  当队列满时，条件是 `(rear + 1) % maxSize == front` 【满】
4. 对队列为空的条件， `rear == front 空`
5. 当我们这样分析， 队列中有效的数据的个数  `(rear + maxSize - front) % maxSize  // rear = 1 front = 0` 
6. 我们就可以在原来的队列上修改得到，一个环形队列

### 总结

先将front和rear的初始值都设为0   必须保证初始值相同

队空:front=rear

队满:(rear+1)%maxSize=front 

进队:(相当于rear往后+1) rear=(rear+1)%maxSize

出队:(相当于front往后+1)front=(front+1)%maxSize

遍历时注意：不是简单的数组长度arr.length   而是front加上有效数据个数



# 链表

## 单链表

### 1.单链表的创建和遍历

添加（创建）

- 先创建一个head 头节点， 作用就是表示单链表的头

- 后面我们每添加一个节点，就直接加入到 链表的最后

  

- ```java
  //添加节点到单向链表
  //思路：当不考虑编号顺序时
  //1.找到当前链表的最后节点
  //2.将最后这个节点的next指向新的节点
  public void add(HeroNode heroNode){
  
      //因为head节点不能动，因此我们需要一个辅助遍历temp
      HeroNode temp=head;
      //遍历链表，找到最后
      while(true){
          //找到链表的最后
          if(temp.next==null){
              break;
          }
          //如果没有找到最后，就将temp后移
          temp=temp.next;
      }
      //当退出while循环时，temp就指向了链表的最后
      //将最后这个节点的next指向新的节点
      temp.next=heroNode;
  }
  ```

遍历：

​	通过一个辅助变量遍历，帮助遍历整个链表

```java
//显示链表【遍历】
public void list(){
    //判断链表是否为空
    if(head.next==null){
        System.out.println("链表为空");
    }
    //因为头节点不能动，因此我们需要一个辅助变量来遍历
    HeroNode temp=head.next;
    while(true){
        //判断是否到链表最后
        if(temp==null){
            break;
        }
        //输出节点的信息
        System.out.println(temp);
        //将temp后移
        temp=temp.next;
    }
}
```

### 2.单链表按顺序插入节点

```java
//第二种方式在添加英雄时，根据排名将英雄插入到指定位置
    // (如果有这个排名，则添加失败，并给出提示)
    public void addByOrder(HeroNode heroNode) {
        //因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置
        //因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了
        HeroNode temp = head;
        boolean flag = false;//标志添加的编号是否存在
        while (true) {
            if (temp.next == null) {
                break; //说明temp已在链表的最后
            }
            if (temp.next.no > heroNode.no) {//位置找到，就在temp后面插入
                break;
            } else if (temp.next.no == heroNode.no) {//说明希望添加的heroNode的编号已然存在
                flag=true;//说明编号存在
                break;
            }
            temp=temp.next;
        }
        //判断flag的值
        if(flag){//不能添加，编号存在
            System.out.printf("准备插入的英雄编号%d已经存在,不能加入\n",heroNode.no);
        }else{
            //插入到链表中,temp的后面
            heroNode.next=temp.next;
            temp.next=heroNode;
        }
    }
```



### 3.单链表节点的修改

```java
//修改节点的信息，根据no编号来修改，即no编号不变
//说明
//1.根据newHeroNode 的no 来修改即可
public void update(HeroNode newHeroNode){
    //判断是否为空
    if(head.next==null){
        System.out.println("链表为空");
    }
    //找到需要修改的节点，根据no编号
    //定义一个辅助变量
    HeroNode temp=head.next;
    boolean flag=false;//表示是否找到该节点
    while(true){
        if(temp==null){
            break;//到链表的最后，已遍历完
        }
        if(temp.no== newHeroNode.no){
            //找到
            flag=true;
            break;
        }
        temp=temp.next;
    }
    //根据flag判断是否找到要修改的节点
    if(flag){
        temp.name= newHeroNode.name;
        temp.nickName= newHeroNode.nickName;
    }else{//没有找到
        System.out.printf("没有找到编号%d的节点，不能修改\n",newHeroNode.no);
    }

}
```

### 4.单链表节点的删除

#### 思路

1.  我们先找到 需要删除的这个节点的前一个节点 temp
2. temp.next = temp.next.next
3.  被删除的节点，将不会有其它引用指向，会被垃圾回收机制回收

```java
//删除节点
//思路
//1.head 不能动 因此需要一个辅助节点temp 找到待删除节点的前一个节点
//2.说明 我们在比较时，是temp.next.no 和需要删除的节点的no比较
public void del(int no){
    HeroNode temp=head;
    boolean flag=false;//标志是否找到待删除节点
    while (true){
        if(temp.next==null){
            //已经到链表最后
            break;
        }
        if(temp.next.no==no){
            //找到了待删除节点的前一个节点temp
            flag=true;
            break;
        }
        temp=temp.next;
    }
    if(flag){
        //找到
        //可以删除
        temp.next=temp.next.next;
    }else{
        System.out.printf("要删除的%d 节点不存在",no);
    }
}
```

### 5.实战

#### 1)求单链表中有效节点的个数

```java
//方法:获取到单链表的节点个数（如果是带头节点的链表，需求不统计头节点）
public static int getLength(HeroNode head){
    if(head.next==null){//空链表
        return 0;
    }
    int length=0;
    //定义一个辅助的变量,这里我们没有统计头节点
    HeroNode cur=head.next;
    while (cur!=null){
        length++;
        cur=cur.next;//遍历
    }
    return length;
}
```

#### 2)查找单链表中的倒数第k个节点（新浪面试题）

```java
//查找单链表中的倒数第k个节点【新浪面试】
//思路
//1.编写一个方法，接收head节点，同时接收一个index
//2.index表示是倒数第index个节点
//3.先把链表从头到尾遍历，得到链表的总长度 getLength
//4.得到size后，我们从链表的第一个开始遍历(size-index)个，就可以得到
//5.如果找到了，则返回该节点，否则返回一个null
public static HeroNode findLastIndexNode(HeroNode head,int index){
    //判断如果链表为空
    if(head.next==null){
        return null;
    }
    //第一次遍历得到链表的长度（节点个数）
    int size=getLength(head);
    //第二次遍历 size-index 位置，就是倒数第k个节点
    //先做一个index的校验
    if(index<=0||index>size){
        return null;
    }
    //定义一个辅助变量
    HeroNode cur=head.next;
    for(int i=0;i<size-index;i++){
        cur=cur.next;
    }
    return cur;

}
```

#### 3)单链表反转(腾讯面试题)

##### 思路

- 先定义一个节点 reverseHead = new HeroNode();
- 从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端.
- 原来的链表的head.next = reverseHead.next

![image-20220116233000605](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220116233000605.png)



```java
//将单链表反转
public static void reverseList(HeroNode head) {
    //如果当前链表为空，或者只有一个节点，则无需反转 直接返回
    if(head.next==null||head.next.next==null){
        return;
    }
    //定义一个辅助指针，帮助我们遍历原来的链表
    HeroNode cur=head.next;
    HeroNode next=null;//指向当前节点【cur】的下一个节点
    HeroNode reverseHead=new HeroNode(0,"","");
    //遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端.
    while(cur!=null){
        next=cur.next;//先暂时保存当前节点的下一个节点，后面需要使用
        cur.next=reverseHead.next;//将cur的下一个节点指向新链表的最前端
        reverseHead.next=cur;//将cur连接到新的链表
        cur=next;//让cur后移

    }
    //将head.next指向reverseHead.next 实现单链表的反转
    head.next=reverseHead.next;

}
```

#### 4)从尾到头打印单链表

##### 思路

- 上面的题的要求就是逆序打印单链表.
- 方式1： 先将单链表进行反转操作，然后再遍历即可，这样的做的问题是会破坏原来的单链表的结构，**不建议**
- **方式**2：可以利用栈这个数据结构，将各个节点压入到**栈**中，然后利用栈的**先进后出**的特点，就实现了逆序打印的效果
- **举例演示栈的使用** **Stack**

```java
//方式2
//可以利用栈这个数据结构，将各个节点压入到栈中
// 然后利用栈的先进后出的特点，就实现了逆序打印的效果
public static void reversePrint(HeroNode head){
    if(head.next==null){
        return;//空链表不能打印
    }
    //创建一个要给的栈，将各个节点压入栈
    Stack<HeroNode> stack = new Stack<>();
    HeroNode cur=head.next;
    //将链表的所有节点压入栈
    while(cur!=null){
        stack.push(cur);
        cur=cur.next;
    }
    //将栈中的节点进行打印 .pop出栈
    while(stack.size()>0){
        System.out.println(stack.pop());
    }

}
```

## 双向链表

分析 双向链表的遍历，添加，修改，删除的操作思路===》代码实现

1.遍历和 单链表一样，只是可以向前，也可以向后查找

2.添加 (默认添加到双向链表的最后)

- 先找到双向链表的最后这个节点

- temp.next = newHeroNode

- newHeroNode.pre = temp;

- ![image-20220117193504366](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220117193504366.png)

- 

- ```java
  //添加一个节点到双向链表的最后
  public void add(HeroNode2 heroNode){
  
      //因为head节点不能动，因此我们需要一个辅助遍历temp
      HeroNode2 temp=head;
      //遍历链表，找到最后
      while(true){
          //找到链表的最后
          if(temp.next==null){
              break;
          }
          //如果没有找到最后，就将temp后移
          temp=temp.next;
      }
      //当退出while循环时，temp就指向了链表的最后
      //形成一个双向链表
      temp.next=heroNode;
      heroNode.pre=temp;
  }
  ```

- ```java
  //第二种方式在添加英雄时，根据排名将英雄插入到指定位置
  // (如果有这个排名，则添加失败，并给出提示)
  public void addByOrder(HeroNode2 heroNode) {
      //因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置
      HeroNode2 temp = head;
      boolean flag = false;//标志添加的编号是否存在
      while (true) {
          if (temp.next == null) {
              break; //说明temp已在链表的最后
          }
          if (temp.next.no > heroNode.no) {//位置找到，就在temp后面插入
              break;
          } else if (temp.next.no == heroNode.no) {//说明希望添加的heroNode的编号已然存在
              flag=true;//说明编号存在
              break;
          }
          temp=temp.next;
      }
      //判断flag的值
      if(flag){//不能添加，编号存在
          System.out.printf("准备插入的英雄编号%d已经存在,不能加入\n",heroNode.no);
      }else{
          //插入到链表中,temp的后面
          if(temp.next==null){
              temp.next=heroNode;
              heroNode.pre=temp;
          }
          else{
              heroNode.pre=temp;
              temp.next=heroNode;
              heroNode.next=temp.next;
              temp.next.pre=heroNode;
          }
  
      }
  }
  ```



3.**修改** 思路和 原来的单向链表一样.

4.删除

- 因为是双向链表，因此，我们可以实现自我删除某个节点
- 直接找到要删除的这个节点，比如temp
- temp.pre.next = temp.next
-  temp.next.pre = temp.pre;
- ![image-20220117193453087](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220117193453087.png)




```java
//从双向链表中删除一个节点
//说明
//1.对于双向链表 我们直接可以找到要删除的这个节点
//2.找到后删除即可
public void del(int no){

    //判断当前链表是否为空
    if(head.next==null){
        System.out.println("链表为空，无法删除");
        return;
    }
    HeroNode2 temp=head.next;
    boolean flag=false;//标志是否找到待删除节点
    while (true){
        if(temp==null){
            //已经到链表最后
            break;
        }
        if(temp.no==no){
            //找到了待删除节点的前一个节点temp
            flag=true;
            break;
        }
        temp=temp.next;
    }
    if(flag){
        //找到
        //可以删除
        temp.pre.next=temp.next;
        //这里代码有问题
        //如果是最后一个节点就不需要执行下面这句话，否则会出现空指针
        if(temp.next!=null){
        temp.next.pre=temp.pre;
        }

    }else{
        System.out.printf("要删除的%d 节点不存在",no);
    }
}
```

## 单向环形链表

### 应用：约瑟夫环问题

Josephu 问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1<=k<=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。

![image-20220117203515458](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220117203515458.png)

#### 思路

**构建**一个单向的环形链表思路

1. 先创建第一个节点, 让 first 指向该节点，并形成环形
2. 后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中即可.

**遍历**环形链表

1. 先让一个辅助指针(变量) curBoy，指向first节点
2. 然后通过一个while循环遍历 该环形链表即可 curBoy.next == first 结束

![image-20220117211410375](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220117211410375.png)



小孩出圈的思路分析

![image-20220117211450226](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220117211450226.png)

#### 代码实现

```java
package linkedlist;

public class Josephu {
    public static void main(String[] args) {
        //测试，构建和遍历是否正确
        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
        circleSingleLinkedList.addBoy(5);
        circleSingleLinkedList.showBoy();

        //测试小孩出圈是否正确
        circleSingleLinkedList.countBoy(1,2,5);
    }
}

//创建一个环形的单向链表
class CircleSingleLinkedList{
    //创建一个first节点，当前没有编号
    private Boy first=new Boy(-1);
    //添加小孩节点，构建一个环形的链表
    public void addBoy(int nums){
        //nums 做一个数据校验
        if(nums<1){
            System.out.println("nums的值不正确");
            return;
        }
        Boy curBoy=null;//辅助指针，帮助构建环形链表
        //使用for循环来创建我们的环形链表
        for(int i=1;i<=nums;i++){
            //根据编号，创建小孩节点
            Boy boy=new Boy(i);
            //如果是第一个小孩
            if(i==1){
                first=boy;
                first.setNext(first);//构成环
                curBoy=first;//让curBoy指向第一个小孩
            }else{
                curBoy.setNext(boy);
                boy.setNext(first);
                curBoy=boy;
            }
        }
    }

    //遍历当前的环形链表
    public void showBoy(){
        //链表是否为空
        if(first==null){
            System.out.println("链表为空");
            return;
        }
        //因为first不能动，因此我们仍然使用一个辅助指针完成遍历
        Boy curBoy=first;
        while (true){
            System.out.printf("小孩的编号 %d\n",curBoy.getNo());
            if(curBoy.getNext()==first){
                //已经遍历完毕
                break;
            }
            curBoy=curBoy.getNext();
        }
    }
    //根据用户的输入，计算出小孩出圈的顺序
    /**
     * @param startNo 表示从第几个小孩开始数数
     * @param countNum 表示数几下
     * @param nums    表示最初有多少个小孩在圈中
     */
    public void countBoy(int startNo,int countNum,int nums){
        //先对数据进行校验
        if(first==null||startNo<1||startNo>nums){
            System.out.println("参数输入有误，请重新输入");
            return;
        }
        //创建要给的辅助指针，帮助小孩出圈
        Boy helper=first;
        //需要创建一个辅助指针变量helper 应该指向环形链表最后的节点
        while (true){
            if(helper.getNext()==first){
                //说明helper指向最后
                break;
            }
            helper=helper.getNext();
        }
        //小孩报数前，先让 first 和  helper 移动 k - 1次
        for(int j=0;j<startNo-1;j++){
            first=first.getNext();
            helper=helper.getNext();
        }
        //当小孩报数时，让first 和 helper 指针同时 的移动  m  - 1 次
        //这里是一个循环的操作，直到圈中只有一个节点
        while (true){
            if(helper==first){
                //圈中只有一个节点
                break;
            }
            //让first和helper同时移动countNum-1
            for(int j=0;j<countNum-1;j++){
                first=first.getNext();
                helper=helper.getNext();
            }
            //这时first指向的节点，就是要出圈小孩的节点
            System.out.printf("小孩 %d出圈\n",first.getNo());
            //这时将first指向的小孩节点出圈
            first=first.getNext();
            helper.setNext(first);
        }
        System.out.printf("最后留在圈中的小孩的编号%d \n",first.getNo());
    }
}

//创建一个Boy类，来表示一个节点
class Boy{
    private int no;//编号
    private Boy next;//指向下一个节点
    public Boy(int no){
        this.no=no;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public Boy getNext() {
        return next;
    }

    public void setNext(Boy next) {
        this.next = next;
    }
}
```



# 栈

## 1.数组模拟栈

![image-20220117214806096](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220117214806096.png)

```java
package stack;

import java.util.Scanner;

public class ArrayStackDemo {
    public static void main(String[] args) {
        //测试
        ArrayStack stack = new ArrayStack(4);
        String key="";
        boolean loop=true;//控制是否退出菜单
        Scanner scanner = new Scanner(System.in);
        while (loop){
            System.out.println("show:显示栈");
            System.out.println("exit:退出");
            System.out.println("push:表示添加数据到栈（入栈）");
            System.out.println("pop:表示从栈取出数据（出栈）");
            System.out.println("请输入你的选择");
            key=scanner.next();
            switch (key){
                case "show":
                    stack.list();
                    break;
                case "push":
                    System.out.println("请输入一个数");
                    int value=scanner.nextInt();
                    stack.push(value);
                    break;
                case "pop":
                    try{
                        int res=stack.pop();
                        System.out.printf("出栈的数据是%d\n",res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case "exit":
                    scanner.close();
                    loop=false;
                    break;
                default:
                    break;
            }
        }
    }
}

//定义一个ArrayStack表示栈
class ArrayStack{
    private int maxSize;//栈的大小
    private int[] stack;//数组模拟栈 数据就放在该数组
    private int top=-1;//top表示栈顶

    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack=new int[this.maxSize];
    }

    //栈满
    public boolean isFull(){
        return top==maxSize-1;
    }
    //栈空
    public boolean isEmpty(){
        return top==-1;
    }
    //入栈 push
    public void push(int value){
        //先判断是否满
        if(isFull()){
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top]=value;
    }
    //出栈pop 返回栈顶的数据
    public int pop(){
        //判断是否空
        if(isEmpty()){
            //抛出异常来处理
            throw new RuntimeException("栈空");
        }
        int value=stack[top];
        top--;
        return value;
    }
    //显示栈的情况【遍历】 从栈顶开始显示
    public void list(){
        if(isEmpty()){
            System.out.println("栈空，没有数据");
            return;
        }
        for(int i=top;i>=0;i--){
            System.out.printf("stack[%d]=%d\n",i,stack[i]);
        }
    }
}
```

## 2.单链表模拟栈



```java
package stack;

import java.util.Scanner;
import java.util.Stack;

public class LinkedListStackDemo {
    public static void main(String[] args) {
        //测试
        //创建单向链表实现的栈
        LinkedListStack linkedListStack = new LinkedListStack(5);
        String key = "";//用来接收用户的输入
        boolean loop = true;//控制是否退出菜单
        Scanner input = new Scanner(System.in);
        while(loop) {
            System.out.println();
            System.out.println("show:表示显示栈！");
            System.out.println("exit:退出程序！");
            System.out.println("push:表示添加数据到栈(入栈)！");
            System.out.println("pop:表示从栈中取出数据(出栈)！");

            System.out.println("请输入你的选择~~~");
            key = input.next();
            switch(key) {
                case "show":
                    linkedListStack.show(linkedListStack.head);
                    break;
                case "push":
                    System.out.println("请输入数据");
                    int value = input.nextInt();
                    Node node = new Node(value);
                    linkedListStack.push(node);
                    break;
                case "pop":
                    try {
                        Node res = linkedListStack.pop();
                        System.out.println("出栈的节点是："+res);
                    }catch(Exception e){
                        //如果是一个空栈
                        System.out.println(e.getMessage());
                    }
                    break;
                case "exit":
                    input.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
    }
}

//链表模拟栈
class LinkedListStack{
    public Node head=new Node(-1);//初始化
    public Node top=null;//定义栈顶节点
    public int maxSize; //链表大小
    public LinkedListStack link;//创建一个链表

    public LinkedListStack(int maxSize) {
        this.maxSize = maxSize;
    }

    //判断是否为空
    public boolean isEmpty(){
        return top==null;
    }
    //显示链表【遍历】
    //可以利用栈这个数据结构，将各个节点压入到栈中
    // 然后利用栈的先进后出的特点，就实现了逆序打印的效果
    public  void show(Node head) {
        if (head.next == null) {
            return;//空链表不能打印
        }
        //创建一个要给的栈，将各个节点压入栈
        Stack<Node> stack = new Stack<>();
        Node cur = head.next;
        //将链表的所有节点压入栈
        while (cur != null) {
            stack.push(cur);
            cur = cur.next;
        }
        //将栈中的节点进行打印 .pop出栈
        while (stack.size() > 0) {
            System.out.println(stack.pop());
        }
    }
    //链表有效个数求maxSize
    // 遍历链表,显示链表数量
    public int length(){
        if(head.next == null){
            // System.out.println("链表为空!!!!!!!");
            return 0;
        }
        Node temp = head.next;
        int count = 0;
        while(temp != null){
            count ++;
            temp = temp.next;
        }
        return count;
    }

    //判断是否栈满
    public boolean isFull(){
        return length()==maxSize;
    }

    //入栈
    public void push(Node node){
        Node temp=head;
        while (true){
            //判断是否为节点的最后
            if (temp.next==null){
                break;
            }
            temp=temp.next;
        }
        //当退出while循环时，说明到了最后一个节点
        //将节点添加到链表的最后
        temp.next = node;
        //将top指向这个节点
        top = node;
    }

    //删除节点从单向链表实现的栈中，即出栈
    public Node pop() {
        //将top指针指向的节点出栈
        //因为出栈后，top指针需要向前移动，所以需要一个辅助指针完成出栈
        Node tmp = top;
        //将top指针向前移动一个
        //需要重新遍历链表找到top节点的前一个节点，再由top指针指向这个节点
        Node h = head;
        while(true) {
            //找到top节点的前一个节点
            if(h.next == top) {
                //说明找到了这个节点
                break;
            }
            //如果不是，则指针向后移动
            h = h.next;
        }
        //退出循环后，找到top节点的前一个节点，对top节点进行删除
        h.next = top.next;
        //将top指针指向这个节点,完成top指针的前移动作
        top = h;
        return tmp;
    }

}


//节点类
class Node{
    public int val;
    public Node next;

    public Node(int val) {
        this.val = val;
    }

    @Override
    public String toString() {
        return "Node{" +
                "val=" + val+"}";
    }
}
```

## 3.前缀、中缀、后缀表达式（逆波兰表达式）

### 前缀表达式（波兰表达式）

1)前缀表达式又称波兰式，**前缀表达式的运算符位于操作数之前**

2)**举例说明：** (3+4)×5-6 对应的前缀表达式就是 **- × + 3 4 5 6**



#### **计算机求值**

​	从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果

例如: (3+4)×5-6 对应的前缀表达式就是 **- × + 3 4 5 6 ,** **针对前缀表达式求值步骤如下****:**



1)从**右至左扫描**，将6、5、4、3压入堆栈

2)遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈

3)接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈

4)最后是-运算符，计算出35-6的值，即29，由此得出最终结果



### **中缀表达式**

1. 中缀表达式就是**常见的运算表达式**，如(3+4)×5-6
2. 中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作(前面我们讲的案例就能看的这个问题)，因此，在计算结果时，往往会将**中缀表达式转成其它表达式来操作(一般转成后缀表达式.)**



### **后缀表达式**

1)后缀表达式又称**逆波兰表达式**,与前缀表达式相似，只是运算符位于操作数之后

2)举例说明： (3+4)×5-6 对应的后缀表达式就是 **3 4 + 5 × 6 –**

3)再比如

| 正常的表达式 | 逆波兰表达式  |
| ------------ | ------------- |
| a+b          | a b +         |
| a+(b-c)      | a b c - +     |
| a+(b-c)*d    | a b c – d * + |
| a+d*(b-c)    | a d b c - * + |
| a=1+3        | a 1 3 + =     |

#### **计算机求值**

**从左至右**扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果



### 逆波兰计算器

**我们完成一个逆波兰计算器，要求完成如下任务****:**

1. **输入一个逆波兰表达式(**后缀表达式**），使用栈**(Stack),计算其结果
2. **支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。**
3. **思路分析**
4. **代码完成**

例如: (3+4)×5-6 对应的后缀表达式就是 **3 4 + 5 × 6 - ,** **针对后缀表达式求值步骤如下**

1. 从左至右扫描，将3和4压入堆栈；
2. 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
3. 将5入栈；
4. 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
5. 将6入栈；
6. 最后是—运算符，计算出35-6的值，即29，由此得出最终结果

```java
package stack;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class PolandNotation {
    public static void main(String[] args) {
        //先定义一个逆波兰表达式
        // (30+4)×5-6 => 30 4 + 5 × 6 – =164
        //测试
        //为了方便 数字和符号使用空格隔开
        String suffixExpression="30 4 + 5 * 6 -";
        //思路
        //1.先将"3 4 + 5 × 6 –" 放到ArrayList中
        //2.将ArrayList 传递给一个方法，遍历配合栈完成计算

        List<String > rpnList=getListString(suffixExpression);
        System.out.println("rpnList="+rpnList);

        int res=calculate(rpnList);
        System.out.println("计算的结果是="+res);
    }
    //将一个逆波兰表达式，一次将数据和运算符 放入到ArrayList中
    public static List<String> getListString(String suffixExpression){
        //将 suffixExpression 分割
        String[] split = suffixExpression.split(" ");
        List<String > list=new ArrayList<>();
        for(String ele:split){
            list.add(ele);
        }
        return list;
    }

    //完成对逆波兰表达式的运算
    /*1.从左至右扫描，将3和4压入堆栈；
      2.遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
      3.将5入栈；
      4.接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
      5.将6入栈；
      6.最后是-运算符，计算出35-6的值，即29，由此得出最终结果
     */

    public static int calculate(List<String> ls){
        //创建一个栈
        Stack<String> stack = new Stack<>();
        //遍历ls
        for(String item:ls){
            //这里使用正则表达式来取出数
            if(item.matches("\\d+")){
                //入栈
                stack.push(item);
            }else{
                //pop出两个数并运算,再入栈
                int num2=Integer.parseInt(stack.pop());
                int num1=Integer.parseInt(stack.pop());
                int res=0;
                if(item.equals("+")){
                    res=num1+num2;
                }else if(item.equals("-")){
                    res=num1-num2;
                }else if(item.equals("*")){
                    res=num1*num2;
                }else if(item.equals("/")){
                    res=num1/num2;
                }else{
                    throw new RuntimeException("运算符有误");
                }
                //把res入栈  简单把整数转字符串
                stack.push(res+"");

            }
        }
        //最后留在Stack中的数据是运算结果
        return Integer.parseInt(stack.pop());
    }
}
```

### 中缀转后缀表达式



大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发中，我们需要将 **中缀表达式**转成**后缀表达式**。



1) 初始化两个栈：运算符栈s1和储存中间结果的栈s2；

2) 从左至右扫描中缀表达式；

3) 遇到操作数时，将其压s2；

4) 遇到运算符时，比较其与s1栈顶运算符的优先级：

   1）如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；

   2）否则，若优先级比栈顶运算符的高，也将运算符压入s1；3）否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；

5) 遇到括号时：
    (1) 如果是左括号“(”，则直接压入s1
    (2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃

6) 重复步骤2至5，直到表达式的最右边

7) 将s1中剩余的运算符依次弹出并压入s2

8) 依次弹出s2中的元素并输出，**结果的逆序即为中缀表达式对应的后缀表达式**

![image-20220118191028878](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220118191028878.png)

思路分析：

![image-20220118174139534](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220118174139534.png)



```java
package stack;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class PolandNotation {
    public static void main(String[] args) {

        //完成一个中缀表达式转成后缀表达式
        //说明
        //1. 1+((2+3)×4)-5 => 转成 1 2 3 + 4 × + 5 –
        //2. 因为直接对一个字符串str进行操作不方便，因此先将 "1+((2+3)×4)-5" =>中缀的表达式对应的List
        // 即"1+((2+3)×4)-5" => ArrayList[1,+,(,2,+,3,),*,4,),-,5]
        //3.将得到的中缀表达式对应的List=》后缀表达式对应的List
        //即ArrayList[1,+,(,2,+,3,),*,4,),-,5] =》ArrayList[1,2,3,+,4,×,+,5,–]
        String expression ="1+((2+3)*4)-5";
        List<String> infixExpressionList = toInfixExpressionList(expression);
        System.out.println("中缀表达式"+infixExpressionList);
        List<String> suffixExpressionList = parseSuffixExpressionList(infixExpressionList);
        System.out.println("后缀表达式对应的List"+suffixExpressionList);
        System.out.printf("expression=%d",calculate(suffixExpressionList));
/*

        //先定义一个逆波兰表达式
        // (30+4)×5-6 => 30 4 + 5 × 6 – =164
        //测试
        //为了方便 数字和符号使用空格隔开
        String suffixExpression="30 4 + 5 * 6 -";
        //思路
        //1.先将"3 4 + 5 × 6 –" 放到ArrayList中
        //2.将ArrayList 传递给一个方法，遍历配合栈完成计算

        List<String > rpnList=getListString(suffixExpression);
        System.out.println("rpnList="+rpnList);

        int res=calculate(rpnList);
        System.out.println("计算的结果是="+res);*/
    }

    //即ArrayList[1,+,(,2,+,3,),*,4,),-,5] =》ArrayList[1,2,3,+,4,×,+,5,–]
    //方法将得到的中缀表达式对应的List=》后缀表达式对应的List
    public static List<String> parseSuffixExpressionList(List<String > ls){
        //定义两个栈
        Stack<String > s1=new Stack<>();//符号栈
        //因为s2在转换过程中没有pop操作 而且后面我们还需要逆序输出
        //比较麻烦，这里我们就不用Stack<String> 直接使用List<String> s2
        //Stack<String > s2=new Stack<>();//存放中间结果的栈s2
        List<String> s2=new ArrayList<>();

        //遍历ls
        for(String item:ls){
            //如果是一个数，加入s2
            if(item.matches("\\d+")){
                s2.add(item);
            }else if(item.equals("(")){
                s1.push(item);
            }else if (item.equals(")")){
                //) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
                while (!s1.peek().equals("(")){
                    s2.add(s1.pop());
                }
                s1.pop();//将左括号弹出 消掉
            }else{
                //当s1 item优先级<=s1栈顶运算符
                // 将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较
                //缺少比较优先级高低的方法
                while (s1.size()!=0&&Operation.getValue(s1.peek())>=Operation.getValue(item)){
                    s2.add(s1.pop());
                }
                //还需要将item压入栈
                s1.push(item);
            }
        }
       // 将s1中剩余的运算符依次弹出并加入s2
        while (s1.size()!=0){
            s2.add(s1.pop());
        }
        return s2;//因为s2是有序的 所以按顺序输出就是对应的逆波兰表达式

    }
    
    //方法将中缀表达式转换成对应的List
    public static List<String> toInfixExpressionList(String s){
        //定义一个List，存放中缀表达式对应的内容
        List<String> ls=new ArrayList<>();
        int i=0;//这是一个指针， 用于遍历中缀表达式字符串
        String str;//做对多位数的拼接操作
        char c;//每遍历到一个字符，就放入到c
        do {
            //如果c是一个非数字吗就需要加入到ls中
            if((c=s.charAt(i))<48||((c=s.charAt(i))>57)){
                ls.add(""+c);
                i++;
            }else{//如果是一个数，需要考虑多位数
                str="";//先将str 置成""
                while(i<s.length()&&(c=s.charAt(i))>=48&&(c=s.charAt(i))<=57){
                    str+=c;
                    i++;
                }
                ls.add(str);
            }
        }while (i<s.length());
        return ls;
    }
    //将一个逆波兰表达式，一次将数据和运算符 放入到ArrayList中
    public static List<String> getListString(String suffixExpression){
        //将 suffixExpression 分割
        String[] split = suffixExpression.split(" ");
        List<String > list=new ArrayList<>();
        for(String ele:split){
            list.add(ele);
        }
        return list;
    }

    //完成对逆波兰表达式的运算
    /*1.从左至右扫描，将3和4压入堆栈；
      2.遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
      3.将5入栈；
      4.接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
      5.将6入栈；
      6.最后是-运算符，计算出35-6的值，即29，由此得出最终结果
     */

    public static int calculate(List<String> ls){
        //创建一个栈
        Stack<String> stack = new Stack<>();
        //遍历ls
        for(String item:ls){
            //这里使用正则表达式来取出数
            if(item.matches("\\d+")){
                //入栈
                stack.push(item);
            }else{
                //pop出两个数并运算,再入栈
                int num2=Integer.parseInt(stack.pop());
                int num1=Integer.parseInt(stack.pop());
                int res=0;
                if(item.equals("+")){
                    res=num1+num2;
                }else if(item.equals("-")){
                    res=num1-num2;
                }else if(item.equals("*")){
                    res=num1*num2;
                }else if(item.equals("/")){
                    res=num1/num2;
                }else{
                    throw new RuntimeException("运算符有误");
                }
                //把res入栈  简单把整数转字符串
                stack.push(res+"");

            }
        }
        //最后留在Stack中的数据是运算结果
        return Integer.parseInt(stack.pop());
    }
}

//编写 一个类Operation 可以返回一个运算符对应的优先级
class Operation{
    private static int ADD=1;
    private static int SUB=1;
    private static int MUL=2;
    private static int DIV=2;
    //写一个方法 返回对应的优先级数字
    public static int getValue(String operation){
        int result=0;
        switch (operation){
            case "+":
                result=ADD;
                break;
            case "-":
                result=SUB;
                break;
            case "*":
                result=MUL;
                break;
            case "/":
                result=DIV;
                break;
            default:
                System.out.println("不存在该运算符");
                break;
        }
        return result;
    }
}
```

# 递归

![image-20220118223932577](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220118223932577.png)

简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量。**递归有助于编程者解决复杂的问题**,同时可以让代码变得简洁。

![image-20220118224011635](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220118224011635.png)

## 1.遵守规则

1. 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
2. 方法的局部变量是独立的，不会相互影响, 比如n变量
3. 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.
4. 递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)
5. 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。

## 2.迷宫问题

![image-20220118231749594](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220118231749594.png)

```java
package recursion;

public class MiGong {
    public static void main(String[] args) {
        //先创建一个二维数组，模拟迷宫
        //地图
        int[][] map=new int[8][7];
        //使用1 表示墙
        //上下全部置为1
        for(int i=0;i<7;i++){
            map[0][i]=1;
            map[7][i]=1;
        }
        //左右全部置为1
        for(int i=0;i<8;i++){
            map[i][0]=1;
            map[i][6]=1;
        }
        //设置挡板，1表示
        map[3][1]=1;
        map[3][2]=1;
        //输出地图
        System.out.println("地图的情况");
        for(int i=0;i<8;i++){
            for(int j=0;j<7;j++){
                System.out.print(map[i][j]+" ");
            }
            System.out.println();
        }
        //使用递归回溯给小球找路
        //setWay(map,1,1);
        setWay2(map,1,1);
        //输出新的地图，走过并标识过的
        System.out.println("输出新的地图，走过并标识过的");
        for(int i=0;i<8;i++){
            for(int j=0;j<7;j++){
                System.out.print(map[i][j]+" ");
            }
            System.out.println();
        }
    }

    //使用递归回溯来给小球找路
    //说明
    //1.map表示地图
    //2.i，j表示从地图的哪个位置出发(1,1)
    //3.如果小球能找到map[6][5]则说明通路
    //4.约定：当map[i][j]为0时表示该点没有走过，1为墙，2为通路 3表示该点已经走过，但是不通
    //5.在走迷宫时，我们需要确定一个策略，下->右->上->左 如果该点走不通回溯
    /**
     *
     * @param map 表示地图
     * @param i 从哪个位置开始
     * @param j
     * @return  如果找到通路返回true
     */
    public static boolean setWay(int[][] map,int i,int j){
        if(map[6][5]==2){//通路已经找到
            return true;
        }else{
            if(map[i][j]==0){//如果当前走过点还没走过
                //策略，下->右->上->左
                map[i][j]=2;//假定可以走通
                if(setWay(map,i+1,j)){//向下走
                    return true;
                }else if(setWay(map,i,j+1)){//右
                    return true;
                }else if(setWay(map,i-1,j)){//上
                    return true;
                }else if(setWay(map, i, j-1)){
                    return true;
                }else{
                    //说明该点走不通，是死路
                    map[i][j]=3;
                    return false;
                }

            }else{//如果map[i][j]!=0,可能是1,2,3,
                return false;
            }
        }
    }

    //修改找路的策略改成，上右下左
    public static boolean setWay2(int[][] map,int i,int j){
        if(map[6][5]==2){//通路已经找到
            return true;
        }else{
            if(map[i][j]==0){//如果当前走过点还没走过
                //策略，下->右->上->左
                map[i][j]=2;//假定可以走通
                if(setWay2(map,i-1,j)){//向上走
                    return true;
                }else if(setWay2(map,i,j+1)){//右
                    return true;
                }else if(setWay2(map,i+1,j)){//下
                    return true;
                }else if(setWay2(map, i, j-1)){//左
                    return true;
                }else{
                    //说明该点走不通，是死路
                    map[i][j]=3;
                    return false;
                }

            }else{//如果map[i][j]!=0,可能是1,2,3,
                return false;
            }
        }
    }

}
```

## 3.八皇后问题（回溯算法）

**1.介绍** 

​	八皇后问题，是一个古老而著名的问题，是**回溯算法的典型案例**。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：**任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法**。

![image-20220119200339585](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119200339585.png)

![image-20220119200345555](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119200345555.png)

2.思路分析：

- 第一个皇后先放第一行第一列
- 第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适
- 继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解
- 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.
- 然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 【示意图】

**说明**：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第i+1个皇后，放在第i+1行的第val+1列

```java
package recursion;

public class Queens8 {

    //先定义max表示有多少个皇后
    int max=8;
    static int count=0;
    //定义数组arr 保存皇后放置位置的结果 比如arr={0 , 4, 7, 5, 2, 6, 1, 3}
    int[] arr=new int[max];
    public static void main(String[] args) {
        //测试
        Queens8 queens8 = new Queens8();
        queens8.check(0);
        System.out.println("解法次数="+count);

    }

    //放置第n个皇后
    //特别注意 check是每一次递归时，进入到check 都有for(int i=0;i<max;i++) 回溯
    private void check(int n){
        if(n==max){ //n=8 放第九个 八个已经放好
            print();
            return;
        }
        //依次放入皇后并判断是否冲突
        for(int i=0;i<max;i++){
            //先把当前这个皇后n 放到该行的第1列
            arr[n]=i;
            //判断当放置第n个皇后到第i列时，是否冲突
            if(judge(n)){//不冲突
                //接着放n+1个皇后 开始递归
                check(n+1);
            }
            //如果冲突，就继续执行arr[n]=i;即将第n个皇后放置在本行的后移一个位置
        }
    }
    //查看当我们放置第n个皇后时，检测该皇后是否和前面已经放置的皇后冲突
    /**
     *
     * @param n 表示第n个皇后
     * @return
     */
    private boolean judge(int n){
        for(int i=0;i<n;i++){
            //说明
            //1.arr[i]==arr[n]  判断第n个皇后是否和前面的i个皇后在同一列
            //2.Math.abs(n-i)==Math.abs(arr[n]-arr[i])表示判断第n个皇后是否和第i个皇后在同一斜线
            // n=1 放在第二列 arr[1]=1
            //Math.abs(1-0)=1  Math.abs(arr[n]-arr[i])
            //左边是行  右边是列 斜率=-1 /  1 为斜线   所以加abs
            if(arr[i]==arr[n]||Math.abs(n-i)==Math.abs(arr[n]-arr[i]))
                return false;
        }
        return true;
    }

    //将皇后摆放的位置输出
    private void print(){
        count++;
        for(int i=0;i< arr.length;i++){
            System.out.print(arr[i]+" ");
        }
        System.out.println();
    }
}
```

# 排序算法

## 1.介绍

​	排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。

## 2.**分类**

1. 内部排序：指将需要处理的所有数据都加载到内部存储器中进行排序。

2. 外部排序法：

   数据量过大，无法全部加载到内存中，需要借助外部存储进行

   排序。

   常见的排序算法分类

 ![image-20220119210933643](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119210933643.png)



## 3.算法时间复杂度

**度量一个程序**(算法)执行时间的两种方法

1)事后统计的方法

​	 这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, **这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快**。

2)事前估算的方法

 	通过分析某个算法的**时间复杂度**来判断哪个算法更优.

### 时间频度

​	时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。**一个算法中的语句执行次数称为语句频度或时间频度**。记为T(n)。

![image-20220119211222166](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119211222166.png)

T(n)=n+1;

![image-20220119211236561](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119211236561.png)

T(n)=1;

### 时间复杂度

#### ①忽略常数项

|      | T(n)=2n+20 | T(n)=2*n | T(3n+10) | T(3n) |
| ---- | ---------- | -------- | -------- | ----- |
| 1    | 22         | 2        | 13       | 3     |
| 2    | 24         | 4        | 16       | 6     |
| 5    | 30         | 10       | 25       | 15    |
| 8    | 36         | 16       | 34       | 24    |
| 15   | 50         | 30       | 55       | 45    |
| 30   | 80         | 60       | 100      | 90    |
| 100  | 220        | 200      | 310      | 300   |
| 300  | 620        | 600      | 910      | 900   |

![image-20220119211624902](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119211624902.png)

结论: 

1)2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略

2)3n+10 和 3n 随着n 变大，执行曲线无限接近, 10可以忽略

#### ②**忽略低次项**

|      | T(n)=2n^2+3n+10 | T(2n^2) | T(n^2+5n+20) | T(n^2) |
| ---- | --------------- | ------- | ------------ | ------ |
| 1    | 15              | 2       | 26           | 1      |
| 2    | 24              | 8       | 34           | 4      |
| 5    | 75              | 50      | 70           | 25     |
| 8    | 162             | 128     | 124          | 64     |
| 15   | 505             | 450     | 320          | 225    |
| 30   | 1900            | 1800    | 1070         | 900    |
| 100  | 20310           | 20000   | 10520        | 10000  |

![image-20220119211711185](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119211711185.png)

结论: 

1)2n^2+3n+10 和 2n^2 随着n 变大, 执行曲线无限接近, 可以忽略 3n+10

2)n^2+5n+20 和 n^2 随着n 变大,执行曲线无限接近, 可以忽略 5n+20

#### ③**忽略系数**

|      | T(3n^2+2n) | T(5n^2+7n) | T(n^3+5n) | T(6n^3+4n) |
| ---- | ---------- | ---------- | --------- | ---------- |
| 1    | 5          | 12         | 6         | 10         |
| 2    | 16         | 34         | 18        | 56         |
| 5    | 85         | 160        | 150       | 770        |
| 8    | 208        | 376        | 552       | 3104       |
| 15   | 705        | 1230       | 3450      | 20310      |
| 30   | 2760       | 4710       | 27150     | 162120     |
| 100  | 30200      | 50700      | 1000500   | 6000400    |

![image-20220119211820313](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119211820313.png)

结论: 

1)随着n值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明 这种情况下, 5和3可以忽略。

2)而n^3+5n 和 6n^3+4n ，执行曲线分离，说明多少次方式关键

#### ④总结

1. 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。
2. T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。
3. 计算时间复杂度的方法：

- 用常数1代替运行时间中的所有加法常数 T(n)=n²+7n+6 => T(n)=n²+7n+1
- 修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 => T(n) = n²
- 去除最高阶项的系数 T(n) = n² => T(n) = n² => O(n²)

#### ⑤常见的时间复杂度

**常见的时间复杂度**

1. 常数阶O(1)

   ​	无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)

   ![image-20220119213335397](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119213335397.png)

   ​	上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

   

2. 对数阶O($log_2n$)

   ![image-20220119213409793](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119213409793.png)

![image-20220119213525344](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119213525344.png)

**说明**：在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = $log_2n$也就是说当循环 $log_2n$次以后，这个代码就结束了。因此这个代码的时间复杂度为：O($log_2n$) 。 O($log_2n$**) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(**$log_3n$) .



​	3.线性阶O(n)

![image-20220119213901642](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119213901642.png)

**说明**：这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度

​	4.线性对数阶O($nlog_2n$)

![image-20220119213920840](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119213920840.png)

**说明**：线性对数阶O() 其实非常容易理解，将时间复杂度为O($log_2n$)的代码循环N遍的话，那么它的时间复杂度就是 n * O($log_2n$)，也就是了O($nlog_2n$)

​	5.平方阶O(n^2)

![image-20220119214100921](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119214100921.png)

**说明**：平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O($n*n$)，即 O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m*n)

​	6.立方阶O(n^3)

​	7.k次方阶O(n^k)

**说明**：参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似

​	8.指数阶O(2^n)

![image-20220119212648915](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119212648915.png)

**说明**：

- 常见的算法时间复杂度由小到大依次为：$O(1)<O(log_2n)<O(n)<O(nlog_2n)<O(n²)$$<O(n^3)<O(n^k)<O(2^n)$ ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低
- 从图中可见，我们应该尽可能避免使用指数阶的算法

#### ⑥平均时间复杂度和最坏时间复杂度

- 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。
- 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。
- 平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。

![image-20220119214307098](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119214307098.png)

## 4.算法的空间复杂度

1. 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。
2. 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况
3. 在做算法分析时，**主要讨论的是时间复杂度**。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间.

## 5.冒泡排序

### 1）介绍

​	冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。

​	**因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排序写好后，再进行）**

### 2）图解

**我们举一个具体的案例来说明冒泡法。我们将五个无序的数：**3, 9, -1, 10, 20**使用冒泡排序法将其排成一个**从小到大的有序数列。

![image-20220119215042234](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119215042234.png)

小结冒泡排序规则

1. 一共进行 数组的大小-1 次 大的循环

2. 每一趟排序的次数在逐渐的减少

3. ( 如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序）。这个就是优化

   

```java
package sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class BubbleSort {
    public static void main(String[] args) {
//        int[] arr={3,9,-1,10,20};
//        System.out.println("排序前");
//        System.out.println(Arrays.toString(arr));
        //为了容易理解，展示冒泡排序的演变过程

        //测试一下冒泡排序的速度O(n^2) 给8w个数 测试
        //创建8w个随机数组   测试时间 8s左右
        int[] arr=new int[80000];
        for(int i=0;i<80000;i++){
            arr[i]=(int)(Math.random()*8000000);//生成[0,8000000)值
        }
        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str=simpleDateFormat.format(date1);
        System.out.println("排序前的时间="+date1Str);

        //测试冒泡排序
        bubbleSort(arr);

        Date date2 = new Date();
        String date2Str=simpleDateFormat.format(date2);
        System.out.println("排序后的时间="+date2Str);
		

//        System.out.println("排序后");
//        System.out.println(Arrays.toString(arr));
        /*//第二趟排序，就是将第二大的数排在倒数第二位
        for(int j=0;j<arr.length-1-1;j++){
            //如果前面的数比后面的大，交换
            if(arr[j]>arr[j+1]){
                temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }
        }
        System.out.println("第二趟排序后的数组");
        System.out.println(Arrays.toString(arr));

        //第三趟排序，就是将第三大的数排在倒数第三位
        for(int j=0;j<arr.length-1-2;j++){
            //如果前面的数比后面的大，交换
            if(arr[j]>arr[j+1]){
                temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }
        }
        System.out.println("第三趟排序后的数组");
        System.out.println(Arrays.toString(arr));

        //第四趟排序，就是将第四大的数排在倒数第四位
        for(int j=0;j<arr.length-1-2;j++){
            //如果前面的数比后面的大，交换
            if(arr[j]>arr[j+1]){
                temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }
        }
        System.out.println("第四趟排序后的数组");
        System.out.println(Arrays.toString(arr));
*/
    }

    //将前面的冒泡排序算法 封装成一个方法
    public static void bubbleSort(int[] arr){
        //冒泡排序，将最大的数排在最后   O(n^2)
        int temp=0;//临时变量
        boolean flag=false;//标识变量 是否进行过交换
        for (int i=0;i<arr.length-1;i++) {
            for (int j = 0; j < arr.length - 1 - i; j++) {
                //如果前面的数比后面的大，交换
                if (arr[j] > arr[j + 1]) {
                    flag=true;
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
            if(!flag){
                //一趟排序中一次交换都没有发生
                break;
            }else {
                flag=false;//重置flag 进行下次判断
            }
        }
    }

}

```

## 6.选择排序

​	选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。

### 1）思想

选择排序（select sorting）也是一种简单的排序方法。它的**基本思想**是：第一次从$arr[0]-arr[n-1]$中选取最小值，与$arr[0]$交换，第二次从$arr[1]-arr[n-1]$中选取最小值，与$arr[1]$交换，第三次从$arr[2]-arr[n-1]$中选取最小值，与$arr[2]$交换，…，第i次从$arr[i-1]-arr[n-1]$中选取最小值，与$arr[i-1]$交换，…, 第n-1次从$arr[n-2]-arr[n-1]$中选取最小值，与$arr[n-2]$交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。

### 2）图解

![image-20220119223020456](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119223020456.png)

### 3）实例

![image-20220119223157602](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119223157602.png)



```java
package sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class SelectSort {
    public static void main(String[] args) {
//        int[] arr={101, 34, 119, 1};
        //创建8w个随机数组  测试时间1-2s 比冒泡快很多
        int[] arr=new int[80000];
        for(int i=0;i<80000;i++){
            arr[i]=(int)(Math.random()*8000000);//生成[0,8000000)值
        }

//        System.out.println("排序前\n"+Arrays.toString(arr));
        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str=simpleDateFormat.format(date1);
        System.out.println("排序前的时间="+date1Str);

        selectSort(arr);
//        System.out.println("排序后\n"+Arrays.toString(arr));
        Date date2 = new Date();
        String date2Str=simpleDateFormat.format(date2);
        System.out.println("排序后的时间="+date2Str);

    }

    //选择排序
    public static void selectSort(int[] arr){


        //在推导的过程中，我们发现了规律 因此可以使用一个循环来解决

        //假定第一个数为最小值
        for(int i=0;i< arr.length-1;i++) {
            int minIndex = i;
            int min = arr[i];
            for (int j = i + 1; j < arr.length; j++) {
                if (min > arr[j]) {//说明假定的最小值 不是最小
                    min = arr[j];//重置min
                    minIndex = j;//重置minIndex
                }
            }
            //将最小值，放在arr[0] 即交换
            if (minIndex != i) {
                arr[minIndex] = arr[i];
                arr[i] = min;
            }

        }



        /*

        //使用逐步推导的方式讲解
        //第一轮
        //原始数组: 101, 34, 119, 1
        //第一轮:   1, 34, 119, 101

        //第一轮
        //假定第一个数为最小值
        int minIndex=0;
        int min=arr[0];
        for(int j=0+1;j<arr.length;j++){
            if(min>arr[j]){//说明假定的最小值 不是最小
                min=arr[j];//重置min
                minIndex=j;//重置minIndex

            }
        }
        //将最小值，放在arr[0] 即交换
        if(minIndex!=0) {
            arr[minIndex] = arr[0];
            arr[0] = min;
        }
        System.out.println("第一轮后--");
        System.out.println(Arrays.toString(arr));

        //第二轮
        //假定第一个数为最小值
        minIndex=1;
        min=arr[1];
        for(int j=1+1;j<arr.length;j++){
            if(min>arr[j]){//说明假定的最小值 不是最小
                min=arr[j];//重置min
                minIndex=j;//重置minIndex

            }
        }
        //将最小值，放在arr[0] 即交换
        if(minIndex!=1) {
            arr[minIndex] = arr[1];
            arr[1] = min;
        }
        System.out.println("第二轮后--");
        System.out.println(Arrays.toString(arr));

        //第三轮
        //假定第一个数为最小值
        minIndex=2;
        min=arr[2];
        for(int j=2+1;j<arr.length;j++){
            if(min>arr[j]){//说明假定的最小值 不是最小
                min=arr[j];//重置min
                minIndex=j;//重置minIndex

            }
        }
        //将最小值，放在arr[0] 即交换
        if(minIndex!=2) {
            arr[minIndex] = arr[2];
            arr[2] = min;
        }
        System.out.println("第三轮后--");
        System.out.println(Arrays.toString(arr));
*/

    }
}

```

## 7.插入排序

​	**插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。**

### 1）思想

插入排序（Insertion Sorting）的**基本思想**是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。

### 2）图解

![image-20220119231335331](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119231335331.png)

### 3）实例

![image-20220119231418014](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220119231418014.png)

```java
package sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class InsertSort {
    public static void main(String[] args) {
//        int[] arr = {101, 34, 119, 1,-1,89};
        //创建8w个随机数组  不到0.5s
        int[] arr=new int[80000];
        for(int i=0;i<80000;i++){
            arr[i]=(int)(Math.random()*8000000);//生成[0,8000000)值
        }
        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str=simpleDateFormat.format(date1);
        System.out.println("排序前的时间="+date1Str);

        insertSort(arr);
//        System.out.println("排序后\n"+Arrays.toString(arr));
        Date date2 = new Date();
        String date2Str=simpleDateFormat.format(date2);
        System.out.println("排序后的时间="+date2Str);


    }

    //插入排序
    public static void insertSort(int[] arr) {

        //用for循环简化代码
        for (int i = 1; i < arr.length; i++) {
            //定义待插入的数
            int insertVal = arr[i];
            int insertIndex = i - 1;//即arr[1]前面一个数的下标
            //给inserVal 找到插入的位置
            //1.insertIndex>=0 保证给inserVal 找到插入的位置不越界
            //2.arr[insertIndex]>insertVal 待插入的数还没有找到适当位置 前一个数大于后一个数
            //3.就需要将arr[insertIndex]后移
            while (insertIndex >= 0 && arr[insertIndex] > insertVal) {
                arr[insertIndex + 1] = arr[insertIndex];
                insertIndex--;
            }
            //当退出while循环时，说明插入的位置找到，insertIndex+1
            //这里我们判断是否需要赋值
            if(insertIndex+1==i){
            arr[insertIndex + 1] = insertVal;}
//            System.out.println("第" + i + "轮插入");
//            System.out.println(Arrays.toString(arr));

        }


        /*//使用逐步推导的方式来讲解，便于理解
        //第一轮{101,34,119,1}=》{34,101,119,1}

        //定义待插入的数
        int insertVal=arr[1];
        int insertIndex=1-1;//即arr[1]前面一个数的下标
        //给inserVal 找到插入的位置
        //1.insertIndex>=0 保证给inserVal 找到插入的位置不越界
        //2.arr[insertIndex]>insertVal 待插入的数还没有找到适当位置 前一个数大于后一个数
        //3.就需要将arr[insertIndex]后移
        while (insertIndex>=0&&arr[insertIndex]>insertVal){
            arr[insertIndex+1]=arr[insertIndex];
            insertIndex--;
        }
        //当退出while循环时，说明插入的位置找到，insertIndex+1
        arr[insertIndex+1]=insertVal;
        System.out.println("第一轮插入");
        System.out.println(Arrays.toString(arr));

        //第2轮
        insertVal=arr[2];
        insertIndex=2-1;
        while (insertIndex>=0&&arr[insertIndex]>insertVal){
            arr[insertIndex+1]=arr[insertIndex];
            insertIndex--;
        }
        arr[insertIndex+1]=insertVal;
        System.out.println("第二轮插入");
        System.out.println(Arrays.toString(arr));

        //第3轮
        insertVal=arr[3];
        insertIndex=3-1;
        while (insertIndex>=0&&arr[insertIndex]>insertVal){
            arr[insertIndex+1]=arr[insertIndex];
            insertIndex--;
        }
        arr[insertIndex+1]=insertVal;
        System.out.println("第三轮插入");
        System.out.println(Arrays.toString(arr));
*/

    }
}
```

## 8.希尔排序

### 1）介绍

**简单插入排序存在的问题**

​	我们看简单的插入排序可能存在的问题.

数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), 这样的过程是：

{2,3,4,5,6,6}

{2,3,4,5,5,6}

{2,3,4,4,5,6}

{2,3,3,4,5,6}

{2,2,3,4,5,6}

{1,2,3,4,5,6}

* 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.

​	希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种**插入排序**，它是简单插入排序经过改进之后的一个**更高效的版本**，也称为缩小增量排序。

​	**希尔排序法基本思想**

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止

### 2）图解

![image-20220121190642996](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220121190642996.png)

### 3）实例

![image-20220121210037829](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220121210037829.png)









```java
package sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class ShellSort {
    public static void main(String[] args) {
//        int[] arr={8,9,1,7,2,3,5,4,6,0};
//        shellSort2(arr);
        int[] arr=new int[80000];
        for(int i=0;i<80000;i++){
            arr[i]=(int)(Math.random()*8000000);//生成[0,8000000)值
        }
        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str=simpleDateFormat.format(date1);
        System.out.println("排序前的时间="+date1Str);

        //交换式   
        //shellSort(arr);   5-8s
        //移位式  0.5s以下
        shellSort2(arr);
//    System.out.println("排序后\n"+Arrays.toString(arr));
        Date date2 = new Date();
        String date2Str=simpleDateFormat.format(date2);
        System.out.println("排序后的时间="+date2Str);

    }

    //使用逐步推导的方式推导
    //希尔排序时， 对有序序列在插入时采用交换法
    public static void shellSort(int[] arr){
        int temp=0;
        int count=0;
        //使用循环处理
        for(int gap=arr.length/2;gap>0;gap/=2){
            for(int i=gap;i<arr.length;i++){
                //遍历各组中所有的元素(共gap组，每组x个元素，步长是gap
                for(int j=i-gap;j>=0;j-=gap){
                    //如果当前元素大于加上步长后的那个元素
                    if(arr[j]>arr[j+gap]){
                        temp=arr[j];
                        arr[j]=arr[j+gap];
                        arr[j+gap]=temp;
                    }

                }
            }
//            System.out.println("希尔排序第"+(++count)+"轮="+ Arrays.toString(arr));

        }

/*
        //希尔排序第一轮
        //因为第一轮排序是将10个数据分成五组
        for(int i=5;i<arr.length;i++){
            //遍历各组中所有的元素(共5组，每组2个元素，步长是5)
            for(int j=i-5;j>=0;j-=5){
                //如果当前元素大于加上步长后的那个元素
                if(arr[j]>arr[j+5]){
                    temp=arr[j];
                    arr[j]=arr[j+5];
                    arr[j+5]=temp;
                }

            }
        }
        System.out.println("希尔排序第一轮后="+ Arrays.toString(arr));

        //希尔排序第二轮
        //因为第一轮排序是将10个数据分成五/2=2组
        for(int i=2;i<arr.length;i++){
            //遍历各组中所有的元素(共5组，每组2个元素，步长是5)
            for(int j=i-2;j>=0;j-=2){
                //如果当前元素大于加上步长后的那个元素
                if(arr[j]>arr[j+2]){
                    temp=arr[j];
                    arr[j]=arr[j+2];
                    arr[j+2]=temp;
                }

            }
        }
        System.out.println("希尔排序第二轮后="+ Arrays.toString(arr));

        //希尔排序第三轮
        //因为第一轮排序是将10个数据分成2/2=1
        for(int i=1;i<arr.length;i++){
            //遍历各组中所有的元素(共5组，每组2个元素，步长是5)
            for(int j=i-1;j>=0;j-=1){
                //如果当前元素大于加上步长后的那个元素
                if(arr[j]>arr[j+1]){
                    temp=arr[j];
                    arr[j]=arr[j+1];
                    arr[j+1]=temp;
                }
            }
        }
        System.out.println("希尔排序第三轮后="+ Arrays.toString(arr));
*/

    }

    //对交换式希尔排序进行优化-》移位法
    public static void shellSort2(int[] arr){

        //增量gap并逐渐的减小增量

        for(int gap=arr.length/2;gap>0;gap/=2){
            //从第gap个元素   逐个对其所在的组进行直接插入排序
            for(int i=gap;i<arr.length;i++){
                int j=i;
                int temp=arr[j];
                if(arr[j]<arr[j-gap]){
                    while(j-gap>=0&&temp<arr[j-gap]){
                        //移动
                        arr[j]=arr[j-gap];
                        j-=gap;
                    }
                    //退出while循环后，找到插入位置
                    arr[j]=temp;
                }
            }
        }
    }
}
```

## 9.快速排序

### 1）介绍

**快速排序（Quicksort）是对冒泡排序的一种改进。**基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

### 2）图解

![image-20220121210508534](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220121210508534.png)

### 3）实例

![image-20220121221603587](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220121221603587.png)

```java
package sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class QuickSort {
    public static void main(String[] args) {
//        int[] arr={-9,78,0,23,-567,70};
        //800w数据 快排1s 希尔2s
        int[] arr=new int[8000000];
        for(int i=0;i<8000000;i++){
            arr[i]=(int)(Math.random()*8000000);//生成[0,8000000)值
        }
        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str=simpleDateFormat.format(date1);
        System.out.println("排序前的时间="+date1Str);

        quickSort(arr,0, arr.length-1);
        Date date2 = new Date();
        String date2Str=simpleDateFormat.format(date2);
        System.out.println("排序后的时间="+date2Str);


    }

    public static void quickSort(int[] arr,int left,int right){
        int l=left;//左下标
        int r=right;//右下标
        //pivot 中轴
        int pivot=arr[(left+right)/2];
        int temp=0;//临时变量 作为交换时使用
        while (l<r){
            //在pivot的左边一直找 大于等于pivot的值 才推出
            while(arr[l]<pivot){
                l+=1;
            }
            //在pivot的右边找到小于等于pivot的才退出
            while (arr[r]>pivot){
                r-=1;
            }
            //如果l>=r说明pivot的左右两的值,
            // 已经按照左边全部是小于等于pivot值,右边全部是大于等于pivot值
            if(l>=r){
                break;
            }
            //只要没有执行上一步  就说明已经在左边找到大于pivot的值  右边找到比pivot小的值
            //所以要进行交换
            temp=arr[l];
            arr[l]=arr[r];
            arr[r]=temp;
            //如果交换完后，发现这个arr[l]=pivot 相等  r--，前移
            if(arr[l]==pivot){
                r-=1;
            }
            //如果交换完后，发现这个arr[r]==pivot 值相等 l++ 后移
            if(arr[r]==pivot){
                l+=1;
            }
        }

        //如果l==r 必须让l++ r-- 否则栈溢出
        if(l==r){
            l+=1;
            r-=1;
        }
        //向左递归
        if(left<r){
            quickSort(arr,left,r);
        }
        //向右递归
        if(right>l){
            quickSort(arr,l,right);
        }
    }
}
```

## 10.归并排序

### 1）介绍

归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的**分治**（divide-and-conquer）策略（分治法将问题**分**(divide)成一些小的问题然后递归求解，而**治**(conquer)的阶段则将分的阶段得到的各答案"**修补**"在一起，即分而治之)。

### 2）图解

![image-20220121222102227](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220121222102227.png)

**说明**

​	可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。**分**阶段可以理解为就是递归拆分子序列的过程。

​	再来看看**治**阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤

![image-20220121222301153](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220121222301153.png)



![image-20220121222310291](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220121222310291.png)

### 3）实例

```java
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class MergetSort {
    public static void main(String[] args) {
        //int arr[]={8,4,5,7,1,3,6,2};//8-> 7次 8w->8w-1次 冒泡8w*O(n^2) 
        //800w数据 1s 跟快排差不多
        int[] arr=new int[80000];
        for(int i=0;i<80000;i++){
            arr[i]=(int)(Math.random()*8000000);//生成[0,8000000)值
        }


        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str=simpleDateFormat.format(date1);
        System.out.println("排序前的时间="+date1Str);

        int temp[]=new int[arr.length];//归并排序需要一个额外的空间
        mergeSort(arr,0, arr.length-1,temp);
        Date date2 = new Date();
        String date2Str=simpleDateFormat.format(date2);
        System.out.println("排序后的时间="+date2Str);

//        System.out.println("归并排序后="+ Arrays.toString(arr));
    }

    //分+合的方法
    public static void mergeSort(int[] arr,int left,int right,int[] temp){
        if(left<right){
            int mid=(left+right)/2;
            //向左递归进行分解
            mergeSort(arr, left, mid, temp);
            //向右递归进行分解
            mergeSort(arr, mid+1, right, temp);
            //合并
            merge(arr,left,mid,right,temp);
        }

    }

    //合并的方法

    /**
     *
     * @param arr 排序的初始数组
     * @param left 左边有序序列的初始索引
     * @param mid   中间索引
     * @param right 右边索引
     * @param temp 做中转数组
     */
    public static void merge(int[] arr,int left,int mid,int right,int[] temp){
        int i=left;//初始化i 左边有序序列的初始索引
        int j=mid+1;//初始化j 右边有序序列的初始索引
        int t=0;//指向temp数组的当前索引

        //1
        //先把左右两边（有序）的数组按照规则填充到temp数组
        //直到左右两边的有序序列 有一边处理完毕为止
        while(i<=mid&&j<=right){//继续
            //如果左边有序序列的当前元素 小于等于右边有序序列的当前元素
            //即将左边的当前元素，填充到temp数组
            //然后t++ i++
            if(arr[i]<=arr[j]){
                temp[t]=arr[i];
                t+=1;
                i+=1;
            }else{//反之 将右边有序序列的当前元素 填充到temp数组
                temp[t]=arr[j];
                t+=1;
                j+=1;
            }
        }
        //2
        //把有剩余数据的一边的数据依次全部填充到temp
        while(i<=mid){
            //左边有序序列还有剩余的 就全部填充到temp
            temp[t]=arr[i];
            t+=1;
            i+=1;
        }
        while(j<=right){
            //左边有序序列还有剩余的 就全部填充到temp
            temp[t]=arr[j];
            t+=1;
            j+=1;
        }

        //3
        //将temp数组的元素拷贝到arr
        //并不是每次都拷贝所有
        t=0;
        int templeft=left;
//        System.out.println("templeft= "+templeft+"right= "+right);
        while (templeft<=right){
            //第一次合并 templeft=0，right=1 //templeft=2，right=3//tl=0 r=3
            //最后一次0 7
            arr[templeft]=temp[t];
            t+=1;
            templeft+=1;
        }
    }
}
```

## 11.基数排序

### 1）介绍

1. [基数排序](https://baike.baidu.com/item/基数排序/7875498)（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的[元素分配](https://baike.baidu.com/item/元素分配/2107419)至某些“桶”中，达到排序的作用。
2. 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法
3. 基数排序(Radix Sort)是**[桶排序](http://www.cnblogs.com/skywang12345/p/3602737.html)**的扩展
4. 基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。

### 2）图解

**基数排序基本思想**

​	将所有待比较数值统一为同样的数位长度，数位**较短的数前面补零**。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。



第1轮排序:

(1) 将每个元素的个位数取出，然后看这个数应该放在哪个对应的桶(一个一维数组)

(2) 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)

![image-20220123233822758](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220123233822758.png)



第2轮排序:

(1) 将每个元素的十位数取出，然后看这个数应该放在哪个对应的桶(一个一维数组)

(2) 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)

![image-20220123233844778](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220123233844778.png)

第3轮排序:

(1) 将每个元素百位数取出，然后看这个数应该放在哪个对应的桶(一个一维数组)

(2) 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)

![image-20220123233908339](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220123233908339.png)

### 3）实例

```java
package sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class RadixSort {
    public static void main(String[] args) {
//        int[] arr={53, 3, 542, 748, 14, 214};

        int[] arr=new int[8000000];
        for(int i=0;i<8000000;i++){
            arr[i]=(int)(Math.random()*8000000);//生成[0,8000000)值
        }
        Date date1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str=simpleDateFormat.format(date1);
        System.out.println("排序前的时间="+date1Str);

        radixSort(arr);
        Date date2 = new Date();
        String date2Str=simpleDateFormat.format(date2);
        System.out.println("排序后的时间="+date2Str);

    }

    //基数排序
    public static void radixSort(int[] arr){

        //根据前面的推导过程，我们可以得到基数排序的代码
        //1.得到数组中最大数的位数
        int max=arr[0];//假设第一个 数是最大的
        for(int i=1;i<arr.length;i++){
            if(arr[i]>max){
                max=arr[i];
            }
        }
        //得到最大数的位数
        int maxLength=(max+"").length();

        //定义一个二维数组 表示十个桶 每个桶就是一个一维数组
        //说明
        //1.二维数组包含10个一维数组
        //2.为了防止在放入数的时候 数据溢出 则每个一维数组（桶）大小为arr.length
        //3.基数排序 空间换时间
        int[][] bucket=new int[10][arr.length];

        //为了记录每个桶中，实际存放了多少个数据
        // 我们定义一个一维数组 来记录每个桶每次放入的数据
        //bucketElementCounts 记录的就是bucket[0] 桶放入的数据个数
        int[] bucketElementCounts=new int[10];

        //这里我们使用循环将代码处理
        for(int i=0,n=1;i<maxLength;i++,n*=10){
            //1.针对每个元素的对应位进行排序处理 第一 个位 第二十位 第三百位
            for(int j=0;j< arr.length;j++){
                //取出每个元素的对应位的值
                int digitOfElement=arr[j]/n%10;
                //放入到对应的桶中
                bucket[digitOfElement][bucketElementCounts[digitOfElement]]=arr[j];
                bucketElementCounts[digitOfElement]++;
            }

            //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)
            int index=0;
            //遍历桶 并将桶中的数据放入到原数组
            for(int k=0;k< bucketElementCounts.length;k++) {
                //如果桶中有数据 我们才放入到原数组中
                if (bucketElementCounts[k] != 0) {
                    //循环该桶即第k个桶（即第k个一维数组）放入
                    for (int l = 0; l < bucketElementCounts[k]; l++) {
                        //取出元素放入到arr中
                        arr[index++] = bucket[k][l];
                    }

                }
                //第一轮处理后 需要将 每个bucketElementCounts[k]=0
                bucketElementCounts[k]=0;
            }
//            System.out.println("第"+(i+1)+"轮 对个位排序处理arr=" + Arrays.toString(arr));

        }



/*
        //第一轮  个位

        //定义一个二维数组 表示十个桶 每个桶就是一个一维数组
        //说明
        //1.二维数组包含10个一维数组
        //2.为了防止在放入数的时候 数据溢出 则每个一维数组（桶）大小为arr.length
        //3.基数排序 空间换时间
        int[][] bucket=new int[10][arr.length];

        //为了记录每个桶中，实际存放了多少个数据
        // 我们定义一个一维数组 来记录每个桶每次放入的数据
        //bucketElementCounts 记录的就是bucket[0] 桶放入的数据个数
        int[] bucketElementCounts=new int[10];

        //1.针对每个元素的个位进行排序处理
        for(int j=0;j< arr.length;j++){
            //取出每个元素的个位的值
            int digitOfElement=arr[j]%10;
            //放入到对应的桶中
            bucket[digitOfElement][bucketElementCounts[digitOfElement]]=arr[j];
            bucketElementCounts[digitOfElement]++;
        }

        //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)
        int index=0;
        //遍历桶 并将桶中的数据放入到原数组
        for(int k=0;k< bucketElementCounts.length;k++) {
            //如果桶中有数据 我们才放入到原数组中
            if (bucketElementCounts[k] != 0) {
                //循环该桶即第k个桶（即第k个一维数组）放入
                for (int l = 0; l < bucketElementCounts[k]; l++) {
                    //取出元素放入到arr中
                    arr[index++] = bucket[k][l];
                }

            }
            //第一轮处理后 需要将 每个bucketElementCounts[k]=0
            bucketElementCounts[k]=0;
        }
        System.out.println("第一轮 对个位排序处理arr=" + Arrays.toString(arr));


        //第二轮 针对元素十位进行处理
        for(int j=0;j< arr.length;j++){
            //取出每个元素的十位的值
            int digitOfElement=arr[j]/10%10;
            //放入到对应的桶中
            bucket[digitOfElement][bucketElementCounts[digitOfElement]]=arr[j];
            bucketElementCounts[digitOfElement]++;
        }

        //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)
        index=0;
        //遍历桶 并将桶中的数据放入到原数组
        for(int k=0;k< bucketElementCounts.length;k++){
            //如果桶中有数据 我们才放入到原数组中
            if(bucketElementCounts[k]!=0){
                //循环该桶即第k个桶（即第k个一维数组）放入
                for(int l=0;l< bucketElementCounts[k];l++){
                    //取出元素放入到arr中
                    arr[index++]=bucket[k][l];
                }
            }
            //第二轮处理后 需要将 每个bucketElementCounts[k]=0
            bucketElementCounts[k]=0;
        }
        System.out.println("第二轮 对个位排序处理arr="+ Arrays.toString(arr));

        //第三轮 针对元素百位进行处理
        for(int j=0;j< arr.length;j++){
            //取出每个元素的百位的值
            int digitOfElement=arr[j]/100%10;
            //放入到对应的桶中
            bucket[digitOfElement][bucketElementCounts[digitOfElement]]=arr[j];
            bucketElementCounts[digitOfElement]++;
        }

        //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)
        index=0;
        //遍历桶 并将桶中的数据放入到原数组
        for(int k=0;k< bucketElementCounts.length;k++){
            //如果桶中有数据 我们才放入到原数组中
            if(bucketElementCounts[k]!=0){
                //循环该桶即第k个桶（即第k个一维数组）放入
                for(int l=0;l< bucketElementCounts[k];l++){
                    //取出元素放入到arr中
                    arr[index++]=bucket[k][l];
                }
            }
        }
        System.out.println("第三轮 对个位排序处理arr="+ Arrays.toString(arr));
*/
    }
}
```

## 12.常用排序算法对比

![image-20220124204502974](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220124204502974.png)

**相关术语解释：**

1)**稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；

2)**不稳定**：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；

3)**内排序**：所有排序操作都在内存中完成；

4)**外排序**：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；

5)**时间复杂度：** 一个算法执行所耗费的时间。

6)**空间复杂度**：运行完一个程序所需内存的大小。

7)**n:** 数据规模

8)**k:** “桶”的个数

9)**In-place:**  不占用额外内存

10)**Out-place:** 占用额外内存



# 查找算法

在java中，我们常用的查找有四种:

 **1)** 顺序(**线性**)**查找**

 **2)** **二分查找**/**折半查找**

 **3)** **插值查找**

 **4)** **斐波那契查找**

## 1.线性查找

![image-20220124205309430](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220124205309430.png)

```java
public class SeqSearch {
    public static void main(String[] args) {
        int[] arr={1,9,11,-1,34,89};//没有顺序的数组
        int index=seqSearch(arr,11);
        if(index==-1){
            System.out.println("没有找到");
        }else{
            System.out.println("找到，下标为="+index);
        }

    }

    /**
     * 这里我们实现的线性查找是找到一个满足条件的值，就返回
     * @param arr
     * @param value
     * @return
     */
    public static int seqSearch(int[] arr,int value){
        //线性查找是逐一比对
        for(int i=0;i< arr.length;i++){
            if(arr[i]==value){
                return i;
            }
        }
        return -1;


    }
}
```

## 2.二分查找

二分查找的思路分析

1.  首先确定该数组的中间的下标

   mid = (left + right) / 2

2.  然后让需要查找的数 findVal 和 arr[mid] 比较

- findVal > arr[mid] , 说明你要查找的数在mid 的右边, 因此需要递归的向右查找
- findVal < arr[mid], 说明你要查找的数在mid 的左边, 因此需要**递归**的向左查找
- findVal == arr[mid] 说明找到，就返回

**什么时候我们需要结束递归**

- 找到就结束递归
- 递归完整个数组，仍然没有找到findVal ，也需要结束递归 当 left > right 就需要退出

![image-20220124223558210](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220124223558210.png)

 

```java
package search;

import java.util.ArrayList;

//使用二分查找的前提是有序的
public class BinarySearch {
    public static void main(String[] args) {
        int[] arr={1,8, 10, 89, 1000,1000,1000,1000,1000, 1234};

//      int resIndex=binarySearch(arr,0, arr.length-1,1234 );
//      System.out.println("resIndex="+resIndex);

        ArrayList<Integer> resIndexList=binarySearch2(arr,0, arr.length-1,1000 );
        System.out.println("resIndexList="+resIndexList);


    }

    //二分查找算法

    /**
     *
     * @param arr 数组
     * @param left 左边的索引
     * @param right 右边的索引
     * @param findVal 要查找的值
     * @return 如果找到返回下标 没有找到返回-1
     */
    public static int binarySearch(int[] arr,int left,int right,int findVal){
        //当left>right 时，说明递归整个数组没有找到
        if(left>right){
            return -1;
        }
        int mid=(left+right)/2;
        int midVal=arr[mid];
        if(findVal>midVal){
            //向右递归
            return binarySearch(arr,mid+1,right,findVal);
        }else if(findVal<midVal){
            return binarySearch(arr,left,mid-1,findVal);
        }else{
            return mid;
        }
    }

    //完成一个课后思考题
    //课后思考题： {1,8, 10, 89, 1000, 1000，1234}
    // 当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000.
    //思路分析
    //1.在找到mid索引值时 先不要马上返回
    //2.向mid索引值的左边扫描，将所有满足1000 的元素下标，加入到集合ArrayList
    //3.向mid索引值的右边扫描，将所有满足1000 的元素下标，加入到集合ArrayList
    //4.将ArrayList返回

    public static ArrayList<Integer> binarySearch2(int[] arr, int left, int right, int findVal){
        //当left>right 时，说明递归整个数组没有找到
        if(left>right){
            return new ArrayList<>();
        }
        int mid=(left+right)/2;
        int midVal=arr[mid];
        if(findVal>midVal){
            //向右递归
            return binarySearch2(arr,mid+1,right,findVal);
        }else if(findVal<midVal){
            return binarySearch2(arr,left,mid-1,findVal);
        }else{
            //思路分析
            //1.在找到mid索引值时 先不要马上返回
            //2.向mid索引值的左边扫描，将所有满足1000 的元素下标，加入到集合ArrayList
            //3.向mid索引值的右边扫描，将所有满足1000 的元素下标，加入到集合ArrayList
            //4.将ArrayList返回
            ArrayList<Integer> resIndexList = new ArrayList<>();
            //向mid索引值的左边扫描，将所有满足1000 的元素下标，加入到集合ArrayList
            int temp=mid-1;
            while(true){
                if(temp<0||arr[temp]!=findVal){//退出
                    break;
                }
                // 否则将temp 放入集合中
                resIndexList.add(temp);
                temp-=1;//左移
            }
            resIndexList.add(mid);
            //向mid索引值的右边扫描，将所有满足1000 的元素下标，加入到集合ArrayList
            temp=mid+1;
            while(true){
                if(temp> arr.length-1||arr[temp]!=findVal){//退出
                    break;
                }
                // 否则将temp 放入集合中
                resIndexList.add(temp);
                temp+=1;//右移
            }
            return resIndexList;
        }
    }
}
```

## 3.插值查找

![image-20220125205629056](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220125205629056.png)

![image-20220125205821248](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220125205821248.png)

```java
package search;

import java.util.Arrays;

public class InsertValueSearch {
    public static void main(String[] args) {
        int[] arr=new int[100];
        for(int i=0;i<100;i++){
            arr[i]=i+1;
        }

        int index=insertValueSearch(arr,0, arr.length-1, 100);
        System.out.println("index="+index);
//        System.out.println(Arrays.toString(arr));
    }

    //编写插值查找算法
    //插值查找算法要求有序
    /**
     *
     * @param arr 数组
     * @param left 左边的索引
     * @param right 右边的索引
     * @param findVal 查找的值
     * @return
     */
    public static int insertValueSearch(int[] arr,int left,int right,int findVal){
        System.out.println("查找次数");

        //findVal<arr[0]和findVal>arr[arr.length-1]必须需要
        //否则mid可能越界
        if(left>right||findVal<arr[0]||findVal>arr[arr.length-1]){
            return -1;
        }
        //求出mid
        int mid = left + (right-left) * (findVal-arr[left]) / (arr[right]-arr[left]);
        int midVal=arr[mid];
        if(findVal>midVal){//说明应该向右递归
            return insertValueSearch(arr,mid+1,right,findVal);
        }else if(findVal<midVal){//说明向左递归
            return insertValueSearch(arr,left,mid-1,findVal);
        }else{
            return mid;
        }
    }
}
```

**插值查找注意事项**：

1)对于数据量较大，**关键字分布比较均匀**的查找表来说，采用**插值查找**, **速度较快**

2)关键字分布不均匀的情况下，该方法不一定比折半查找要好。



## 4.斐波那契查找

**斐波那契**(黄金分割法)原理:

![preview](https://pic2.zhimg.com/v2-fb97f3ad169a4feec987a9bda4d9e849_r.jpg)

​	上述性质可以用于数据区间分割，**将一个长度为F(n)数组看做前后两半，前面一半长度是F(n-1)，后面一半的长度是F(n-1)**。正是这个想法将斐波那契数列和数组联系到一起，也是后面分析的基础：

​	**斐波那契查找**原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即**mid=**low+F**(k-1)-1**（F代表斐波那契数列），如下图所示

![image-20220125211921982](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220125211921982.png)

**对**F(k-1)-1的理解：

1. 由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 **（**F[k]-1**）=**（**F[k-1]-1**）**+**（**F[k-2]-1**）**+1** 。该式说明：只要顺序表的长度为**F[k]-1**，则可以将该表分成长度为**F[k-1]-1**和**F[k-2]-1**的两段，即如上图所示。从而中间位置为**mid=**low+F**(k-1)-1**      
2. 类似的，每一子段也可以用相同的方式分割
3. 但顺序表长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。这里的k值只要能使得F[k]-1恰好大于或等于n即可，由以下代码得到,顺序表长度增加后，新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可。

**斐波那契查找的整个过程可以分为：**

- 构建斐波那契数列；
- 计算数组长度对应的斐波那契数列元素个数；

- 对数组进行填充；
- 循环进行区间分割，查找中间值；
- 判断中间值和目标值的关系，确定更新策略；

![img](https://img-blog.csdnimg.cn/2021031420274360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW5ncWl1bWluZw==,size_16,color_FFFFFF,t_70)

```java
package search;

import java.util.Arrays;

public class FibonacciSearch {

    public static int maxSize = 20;
    public static void main(String[] args) {
        int [] arr = {1,8, 10, 89, 1000, 1234};

        System.out.println("index=" + fibSearch(arr, 189));// 0

    }

    //因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列
    //非递归方法得到一个斐波那契数列
    public static int[] fib() {
        int[] f = new int[maxSize];
        f[0] = 1;
        f[1] = 1;
        for (int i = 2; i < maxSize; i++) {
            f[i] = f[i - 1] + f[i - 2];
        }
        return f;
    }

    //编写斐波那契查找算法
    //使用非递归的方式编写算法
    /**
     *
     * @param a  数组
     * @param key 我们需要查找的关键码(值)
     * @return 返回对应的下标，如果没有-1
     */
    public static int fibSearch(int[] a, int key) {
        int low = 0;
        int high = a.length - 1;
        int k = 0; //表示斐波那契分割数值的下标
        int mid = 0; //存放mid值
        int f[] = fib(); //获取到斐波那契数列
        //获取到斐波那契分割数值的下标
        while(high > f[k] - 1) {
            k++;
        }
        //将一个长度为F(n)数组看做前后两半，前面一半长度是F(n-1)，后面一半的长度是F(n-1)
        //因为 f[k] 长度  可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]
        //a数组 f【k】新数组长度不足的部分会使用0填充
        int[] temp = Arrays.copyOf(a, f[k]);
        //实际上需求使用a数组最后的数填充 temp
        //举例:
        //temp = {1,8, 10, 89, 1000, 1234, 0, 0}  => {1,8, 10, 89, 1000, 1234, 1234, 1234,}
        for(int i = high + 1; i < temp.length; i++) {
            temp[i] = a[high];
        }

        // 使用while来循环处理，找到我们的数 key
        while (low <= high) { // 只要这个条件满足，就可以找
            mid = low + f[k - 1] - 1;
            if(key < temp[mid]) { //我们应该继续向数组的前面查找(左边)
                high = mid - 1;
                //为甚是 k--
                //说明
                //1. 全部元素 = 前面的元素 + 后边元素
                //2. f[k] = f[k-1] + f[k-2]
                //因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]
                //本轮查询是在 f[k]-1 个数中进行，下次查询是在f[k-1]-1 个数中进行，所以是 k--
                //
                k--;
            } else if ( key > temp[mid]) { // 我们应该继续向数组的后面查找(右边)
                low = mid + 1;
                //为什么是k -=2
                //说明
                //1. 全部元素 = 前面的元素 + 后边元素
                //2. f[k] = f[k-1] + f[k-2]
                //3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-2] = f[k-3] + f[k-4]
                //4. 本轮查询是在 f[k]-1 个数中进行，下次查询是在f[k-2]-1 个数中进行，所以是k-2
                //5.
                k -= 2;
            } else { //找到
                //需要确定，返回的是哪个下标
                if(mid <= high) {
                    return mid;
                } else {
                    return high;
                }
            }
        }
        return -1;
    }
}
```

# 哈希表

​	[散列表](https://baike.baidu.com/item/散列表)（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的[数据结构](https://baike.baidu.com/item/数据结构/1450)。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做[散列函数](https://baike.baidu.com/item/散列函数)，存放记录的[数组](https://baike.baidu.com/item/数组)叫做[散列表](https://baike.baidu.com/item/散列表)。

![image-20220125233125187](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220125233125187.png)

![image-20220125233220943](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220125233220943.png)



# 动态规划算法

## 1.介绍

1. 动态规划(**Dynamic Programming**)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法

2. 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。

3. 与分治法不同的是，**适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。** ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )

4. 动态规划可以通过**填表的方式**来逐步推进，得到最优解.

   

## 2.实践

背包问题：有一个背包，容量为4磅 ， 现有如下物品

| **物品** | **重量** | **价格** |
| -------- | -------- | -------- |
| 吉他(G)  | 1        | 1500     |
| 音响(S)  | 4        | 3000     |
| 电脑(L)  | 3        | 2000     |

1)要求达到的目标为装入的背包的总价值最大，并且重量不超出

2)要求装入的物品不能重复

3)思路分析和图解

•背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包(完全背包指的是：每种物品都有无限件可用)

•这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包。

![image-20220109161702744](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220109161702744.png)

![image-20220109161709446](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220109161709446.png

![image-20220109171139215](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220109171139215.png)

![image-20220109161727686](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220109161727686.png)

```
	(1) v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是0
	(2) 当w[i]> j 时：v[i][j]=v[i-1][j]  // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略
   (3) 当j>=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} 

// 当 准备加入的新增的商品的容量小于等于当前背包的容量,
// 装入的方式:

v[i-1][j]： 就是上一个单元格的装入的最大值

v[i] : 表示当前商品的价值 

v[i-1][j-w[i]] ： 装入i-1商品，到剩余空间j-w[i]的最大值

当j>=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} :
```

思路：装入本行物品，即先
